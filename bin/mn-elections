#!/usr/bin/env node

/**
 * Main command line app.
 */

// Dependencies
require('dotenv').load();
const command = require('yargs');
const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const mkdirp = require('mkdirp');
const lSymbols = require('log-symbols');
const ora = require('ora');
const inquirer = require('inquirer');
const Table = require('easy-table');

const Election = require('../lib/election.js');
const verify = require('../lib/verify.js');
const Publish = require('../lib/publish.js');
const debug = require('debug')('mn-elections-api:cmd');

// Add some more symbols
lSymbols.dot = 'ยบ';

// Set up command line
command.usage('\nUsage:\n  $0 <cmd> [args]');

// General debug option
command.option('debug', {
  alias: 'd',
  describe: 'Turn on debugging.',
  type: 'boolean'
});

// Elections JSON location
command.option('config', {
  alias: 'c',
  describe: 'Location of JSON describing elections.',
  type: 'string',
  demandOption: true,
  default: path.join(__dirname, '..', 'elections.json')
});

// Common options, but specific to command
let common = {
  election: {
    alias: 'e',
    demandOption: true,
    describe:
      'Election ID to use. To see all possible elections, use the `list` command.',
    type: 'string'
  },
  output: {
    alias: 'o',
    demandOption: true,
    describe: 'Path to output election to.',
    type: 'string',
    default: './mn-elections-output'
  }
};

// List command
command.command(
  'list',
  'List available elections.',
  y => {
    return y.usage('\nList usage:\n  $0 list');
  },
  y => {
    let elections = getElections(y);
    updateDebug(y);

    output('\nAvailable elections:', '\n');

    let data = [];
    _.each(elections, (election, k) => {
      if (k.match(/[0-9]+/) && _.isPlainObject(election)) {
        data.push({
          id: k,
          general:
            !election.primary && !election.special
              ? lSymbols.success
              : undefined,
          primary: election.primary ? lSymbols.success : undefined,
          special: election.special ? lSymbols.success : undefined,
          supplemented: election.supplement ? lSymbols.success : undefined
        });
      }
    });

    output(Table.print(data));
  }
);

// Results command
command.command(
  'results',
  'Get results for an election.',
  y => {
    return y
      .usage('\nResults usage:\n  $0 results -e <election> [args]')
      .option('election', common.election)
      .option('output', common.output);
  },
  async y => {
    let elections = getElections(y);
    updateDebug(y);
    checkElection(y);

    // Check id in election
    elections[y.election].id = elections[y.election].id || y.election;

    output('\nCompiling election results for "' + y.election + '":', '\n');
    let spinCreate = ora('Loading election').start();

    // Create election object
    let e;
    try {
      e = new Election(elections[y.election], {
        exportPath: path.join(y.output, y.election)
      });
      spinCreate.succeed();
    }
    catch (e) {
      spinCreate.fail();
      debug(e);
      error('Error trying to create election "' + y.election + '"');
    }

    // Fetch
    let spinFetch = ora('Fetching results').start();
    try {
      await e.fetchResults();
      spinFetch.succeed();
    }
    catch (e) {
      spinFetch.fail();
      debug(e);
      error('Error trying fetch results for election "' + y.election + '"');
    }

    // Verify
    let spinVerify = ora('Verifying results').start();
    try {
      let verified = e.verify();
      if (verified === true) {
        spinVerify.succeed();
        output('');
      }
      else if (verified === false) {
        spinVerify.warn('No contest counts provided in config JSON.');
        output('');
      }
      else {
        spinVerify.fail();
        error(verified);
      }
    }
    catch (e) {
      spinVerify.fail();
      debug(e);
      error('Error verifying results for election "' + y.election + '"');
    }
  }
);

// Setup supplement
command.command(
  'setup',
  'Setup supplement datasource (Airtable).',
  y => {
    return y
      .usage('\nSetup supplement usage:\n  $0 setup -e <election> [args]')
      .option('election', common.election)
      .option('output', common.output);
  },
  async y => {
    let elections = getElections(y);
    updateDebug(y);
    checkElection(y);

    // Check id in election
    elections[y.election].id = elections[y.election].id || y.election;

    // Title
    output(
      '\nSetup supplement datasource for "' +
        y.election +
        '" at Airtable "' +
        elections[y.election].supplement.id +
        '":',
      '\n'
    );

    // Confirm
    try {
      let answers = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'confirm',
          message:
            'Setup will not overwrite any rows in the datasource, but \nwill create new data.  Are you sure?',
          default: true
        }
      ]);
      if (!answers.confirm) {
        error('Exiting.');
      }

      output('');
    }
    catch (e) {
      debug(e);
      error('Exiting.');
    }

    // Create election object
    let spinCreate = ora('Loading election').start();
    let e;
    try {
      e = new Election(elections[y.election], {
        exportPath: path.join(y.output, y.election)
      });
      spinCreate.succeed();
    }
    catch (e) {
      spinCreate.fail();
      debug(e);
      error('Error trying to create election "' + y.election + '"');
    }

    // Fetch
    let spinFetch = ora('Fetching results').start();
    try {
      await e.fetchResults();
      spinFetch.succeed();
    }
    catch (e) {
      spinFetch.fail();
      debug(e);
      error('Error trying fetch results for election "' + y.election + '"');
    }

    // Fetch
    let spinSetup = ora('Setting up datasource.').start();
    try {
      await e.setupSupplement();
      spinSetup.succeed();
      output('');
    }
    catch (e) {
      spinSetup.fail();
      debug(e);
      error(
        'Error trying to setup datasource for election "' + y.election + '"'
      );
    }
  }
);

// Verify
command.command(
  'verify',
  'Verify results from SoS with independent counts.',
  y => {
    return y
      .usage('\nVerify usage:\n  $0 verify -e <election> [args]')
      .option('election', common.election)
      .option('update', {
        alias: 'u',
        describe: 'Update the config JSON with found values.',
        type: 'confirm',
        default: false
      });
  },
  async y => {
    let elections = getElections(y);
    updateDebug(y);
    checkElection(y);

    // Check id in election
    let e = elections[y.election];
    e.id = e.id || y.election;

    // Title
    output('\nVerify results for "' + y.election + '"', '\n');

    // Confirm if update
    if (y.update) {
      let answers = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'confirm',
          message:
            'Updating will overwrite your config JSON. Are you sure you want to do this?',
          default: false
        }
      ]);
      output('');

      if (!answers.confirm) {
        error('Exiting.');
      }
    }

    // Verify
    try {
      let results = await verify(e.sos, e.results);
      output(Table.print(results));

      // Update
      if (y.update) {
        e.results = results;
        fs.writeFileSync(
          path.resolve(y.config),
          JSON.stringify(elections, null, '  ')
        );
      }
    }
    catch (e) {
      debug(e);
      error(
        'Issue with getting or saving verification results for election "' +
          y.election +
          '"'
      );
    }
  }
);

// Publish
command.command(
  'publish',
  'Publish results to S3.',
  y => {
    return y
      .usage('Publish usage:\n  $0 publish -e <election> -s <s3-path> [args]')
      .option('election', common.election)
      .option('output', common.output)
      .option('s3', {
        alias: 's',
        describe: 'S3 URI to publish to, such as "s3://bucket/path/to/export".',
        type: 'string',
        demandOption: true
      })
      .option('version', {
        alias: 'i',
        describe:
          'Whether to create export to a versioned path. This will append "_versions/TIMESTAMP" to the path.',
        type: 'confirm',
        default: false
      });
  },
  async y => {
    let elections = getElections(y);
    updateDebug(y);
    checkElection(y);

    // Check id in election
    let e = elections[y.election];
    e.id = e.id || y.election;

    // Title
    output('\nPublish results for "' + y.election + '"', '\n');

    // Create election object
    let spinCreate = ora('Loading election').start();
    try {
      e = new Election(elections[y.election], {
        exportPath: path.join(y.output, y.election)
      });
      spinCreate.succeed();
    }
    catch (e) {
      spinCreate.fail();
      debug(e);
      error('Error trying to create election "' + y.election + '"');
    }

    // Publish
    let publishCreate = ora('Publishing election').start();
    try {
      let p = new Publish(e, {
        exportPath: path.join(y.output, y.election),
        s3Location: y.s3
      });
      await p.publish(y.version);
      publishCreate.succeed();
    }
    catch (e) {
      publishCreate.fail();
      debug(e);
      error('Issue with publishing results for election: "' + y.election + '"');
    }
  }
);

// Print command
command.command(
  'print',
  'Get results for an election and print out saxotech-style.',
  y => {
    return y
      .usage('\nPrint usage:\n  $0 print -e <election> [args]')
      .option('election', common.election)
      .option('output', common.output);
  },
  async y => {
    let elections = getElections(y);
    updateDebug(y);
    checkElection(y);

    // Check id in election
    elections[y.election].id = elections[y.election].id || y.election;

    output('\nCompiling election results for "' + y.election + '":', '\n');
    let spinCreate = ora('Loading election').start();

    // Create election object
    let e;
    try {
      e = new Election(elections[y.election], {
        exportPath: path.join(y.output, y.election)
      });
      spinCreate.succeed();
    }
    catch (e) {
      spinCreate.fail();
      debug(e);
      error('Error trying to create election "' + y.election + '"');
    }

    // Fetch
    let spinFetch = ora('Fetching results').start();
    try {
      await e.fetchResults();
      spinFetch.succeed();
    }
    catch (e) {
      spinFetch.fail();
      debug(e);
      error('Error trying fetch results for election "' + y.election + '"');
    }

    // Verify
    output('Printing... \n\n');
    try {
      e.exportPrint();
    }
    catch (e) {
      debug(e);
      error('Error printing results for election "' + y.election + '"');
    }
  }
);

// Setup help and parse
command.help().argv;

// Get elections
function getElections(y) {
  if (!y.config || !fs.existsSync(path.resolve(y.config))) {
    error('Unable to find elections JSON at: ' + y.config);
  }

  return require(y.config);
}

// Check election arguments
function checkElection(y) {
  let elections = getElections(y);

  // Check election
  if (!y.election || !elections[y.election]) {
    error(
      'Election "' +
        y.election +
        '" not found; use the `list` command to see available elections.'
    );
  }

  // Check output
  if (y.output) {
    let output = path.resolve(y.output);
    try {
      mkdirp.sync(output);
    }
    catch (e) {
      debug(e);
      error('Error trying to create output directory "' + output + '"');
    }
  }
}

// Handle debug
function updateDebug(y) {
  if (y.debug) {
    process.env.DEBUG = process.env.DEBUG === '*' ? '*' : 'mn-elections-api:*';
    debug.enabled = true;
  }
}

// General output function
function output(...args) {
  console.error(...args);
}

// Error
function error(...args) {
  output(...['\n', lSymbols.error, ...args, '\n']);
  process.exit(1);
}
